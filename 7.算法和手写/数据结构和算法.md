## 算法概念
算法（Algorithm）， 是指解决问题的思想与方案，最终是为了解决现实问题服务的。
## 数据结构 
Data Structure，指计算机中存储、组织数据的方式。 例如链表、二叉树、堆栈、红黑树等。
## 算法复杂度 
不同算法也有优劣之分，如消耗时间的长短、占用内存的大小，这也就是我们常说的算法复杂 度。算法复杂度分为时间复杂度和空间复杂度。 
#### 时间复杂度 
Time Complexity，又叫时间复杂性，用来描述该算法的运行时间。常用大O符号表述，如 O(1)、O(n)等。常见的时间复杂度量级有： 
* 常数时间O(1)
* 对数时间O(logN)
* 线性时间O(n)
* 线性对数（准线性）时间O(nlogN)
* 平方时间O(n²)
* 立方时间O(n³) 
如访问数组中的某个下标的元素，时间复杂度就是O(1)；查找乱序数组中的最小值，时间复杂 度就是O(n)，二分搜索的时间复杂度就是O(logN)。 
相同大小的不同输入值仍可能造成算法的运行时间不同，因此时间复杂度又有三种场景区分：最 优情况的时间复杂度、最差情况的时间复杂度以及平均情况时间复杂度。通常情况下，某个算法 的时间复杂度，我们说的都是平均情况时间复杂度。
#### 空间复杂度
Space Complexity，描述该算法或程序运行所需要的存储空间大小。和时间复杂度一样，也常 用大O符号表述，如O(1)、O(n)等。
#### [位运算](https://juejin.cn/post/6900710763657166855?searchId=20241015114937C95E27017F9CC318B3BB)
* 按位非 NOT（~）：按位非的最终结果始终是对原数值取反并减一，~x = (-x) - 1，即 0 变为 -1，1 变为 -2，2变为 -3，以此类推。取整：~~3.14 == 3。
* 按位与 AND（&）：判断奇偶性 偶数 & 1 == 0  奇数 & 1 === 1。
* 按位或 OR（|）：取整 1.111 | 0 === 1  2.234 | 0 === 2。
* 按位异或 XOR（^）：判断整数部分是否相等 2.1 ^ 2.5 === 0  2.2 ^ 2.6 === 0  2.1 ^ 3.1 === 1。判断两数符号是否相同  (a ^ b) >= 0 === true。
* 左移（<<）：x << y 等同于 x * 2^y。
* 有符号右移（>>）：x >> y 等同于 x / 2^y。
* 无符号右移（>>>）：对于正数，无符号右移会给空位都补 0 ，不管符号位是什么，这样的话正数的有符号右移和无符号右移结果都是一致的，负数就不一样了，当把一个负数进行无符号右移时也就是说把负数的二进制码包括符号为全部右移，向右被移出的位被丢弃，左侧用0填充，由于符号位变成了 0，所以结果总是非负的。
#### [归并排序、快速排序、希尔排序、堆排序](https://juejin.cn/post/6844903895789993997)
常用排序算法稳定性、时间复杂度分析
![on](https://github.com/lujiajian1/study-notes/blob/main/img/on.png)
## 数组/字符串
#### 手写数组 flatern（数组拍平）
```js
//使用apply
function flat(arr) {
  // 验证 arr 中，还有没有深层数组 [1, 2, [3, 4]]
  const isDeep = arr.some((item) => item instanceof Array);
  if (!isDeep) {
    return arr; // 已经是 flatern [1, 2, 3, 4]
  }

  const res = Array.prototype.concat.apply([], arr);
  return flat(res); // 递归
}

const res = flat([1, 2, [3, 4, [10, 20, [100, 200]]], 5]);
console.log(res);

//使用展开运算符
function arrf(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] instanceof Array) {
      res = res.concat(arrf(arr[i]));
    } else {
      res.push(arr[i]);
    }
  }
  return res;
}
```
#### 冒泡排序
遍历整个数组，将数组的每一项与其后一项进行对比，如果不符合要求就交换位置，一共遍历 n 轮，n 为数组的长度。n 轮之后，数组得以完全排序。时间复杂度 O(n^2)。
```js
function bubbleSort(arr) {
  //console.time('BubbleSort');
  // 获取数组长度，以确定循环次数。
  let len = arr.length;
  // 遍历数组len次，以确保数组被完全排序。
  for (let i = 0; i < len; i++) {
    // 遍历数组的前len-i项，忽略后面的i项（已排序部分）。
    for (let j = 0; j < len - 1 - i; j++) {
      // 将每一项与后一项进行对比，不符合要求的就换位。
      if (arr[j] > arr[j + 1]) {
        //从小到大排序
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
      }
    }
  }
  //console.timeEnd('BubbleSort');
  return arr;
}
```
#### 快速排序
在数组中选取一个参考点（pivot），然后对于数组中的每一项，大于 pivot 的项都放到数组右边，小于 pivot 的项都放到左边，左右两边的数组项可以构成两个新的数组（left 和 right），然后继续分别对 left 和 right 进行分解，直到数组长度为 1，最后合并（其实没有合并，因为是在原数组的基础上操作的，只是理论上的进行了数组分解）。
```js
//递归
function quickSort(arr) {
  // 当数组长度不大于1时，返回结果，防止callstack溢出。
  if (arr.length <= 1) return arr;
  return [
    // 递归调用quickSort，通过Array.prototype.filter方法过滤小于arr[0]的值，注意去掉了arr[0]以防止出现死循环。
    ...quickSort(arr.slice(1).filter((item) => item < arr[0])),
    arr[0],
    ...quickSort(arr.slice(1).filter((item) => item >= arr[0])),
  ];
}
//非递归
const quickSort1 = (arr) => {
  if (arr.length <= 1) {
    return arr;
  }
  //取基准点
  const midIndex = Math.floor(arr.length / 2);
  //取基准点的值，splice(index,1) 则返回的是含有被删除的元素的数组。
  const valArr = arr.splice(midIndex, 1);
  const midIndexVal = valArr[0];
  const left = []; //存放比基准点小的数组
  const right = []; //存放比基准点大的数组
  //遍历数组，进行判断分配
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] < midIndexVal) {
      left.push(arr[i]); //比基准点小的放在左边数组
    } else {
      right.push(arr[i]); //比基准点大的放在右边数组
    }
  }
  //递归执行以上操作，对左右两个数组进行操作，直到数组长度为 <= 1
  return quickSort1(left).concat(midIndexVal, quickSort1(right));
};
const array2 = [5, 4, 3, 2, 1];
console.log("quickSort1 ", quickSort1(array2));
// quickSort1: [1, 2, 3, 4, 5]
```
#### 归并排序
排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。
```js
const mergeSort = (arr) => {
  //采用自上而下的递归方法
  const len = arr.length;
  if (len < 2) {
    return arr;
  }
  // length >> 1 和 Math.floor(len / 2) 等价
  let middle = Math.floor(len / 2),
    left = arr.slice(0, middle),
    right = arr.slice(middle); // 拆分为两个子数组
  return merge(mergeSort(left), mergeSort(right));
};
const merge = (left, right) => {
  const result = [];

  while (left.length && right.length) {
    // 注意: 判断的条件是小于或等于，如果只是小于，那么排序将不稳定.
    if (left[0] <= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }

  while (left.length) result.push(left.shift());

  while (right.length) result.push(right.shift());

  return result;
};
```
#### 二分查找
Binary Search，也称折半查找，它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。
```js
/**
 * 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜 索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
 * @param {number[]} nums
 * @param {number} target
 * @return {number} 
*/ 
var search = function(nums, target) { 
    let low = 0, high = nums.length-1;
    while(low<=high) { 
        const mid = (low + high)>>1;
        const num = nums[mid];
        if(num===target) { 
            return mid;
        } else if(num>target) {
            // 值在左边
            high = mid - 1;
        } else {
            // 值在右边
            low = mid + 1;
        } 
    }
    return -1;
};
```
#### 二分法插入排序
相关的还有二分法插入排序，简称二分排序，是在插入第i个元素时，对前面的0～i-1元素进行 折半，先跟他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半，直到 left \< right，然后再把第i个元素前1位与目标位置之间的所有元素后移，再把第i个元素放在目标 位置上。 动态规划经常会用到二分思想来做优化。
```js
// 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数 组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。
var searchInsert = function(nums, target) {
    const n = nums.length;
    let left = 0, right = n - 1, ans = n;
    while (left <= right) {
        let mid = ((right - left) >> 1) + left;
        if (target <= nums[mid]) {
            ans = mid; right = mid - 1;
        } else {
            left = mid + 1;
        } 
    }
    return ans;
};
```
#### [下一个排列](https://leetcode-cn.com/problems/next-permutation/)
```js
var nextPermutation = function (nums) {
  // 从又往左找到第一个降序的位置
  let right = nums.length - 1;
  let flag = false;
  while (right) {
    if (nums[right] > nums[right - 1]) {
      right--;
      flag = true;
      break;
    } else {
      right--;
    }
  }
  if (!flag) {
    nums.sort((next, pre) => next - pre);
  } else {
    let sorted = nums.splice(right + 1).sort((next, pre) => next - pre);
    let move;
    for (let i = 0; i < sorted.length; i++) {
      if (sorted[i] > nums[right]) {
        move = i;
        break;
      }
    }
    let temp = sorted[move];
    sorted[move] = nums[right];
    nums[right] = temp;
    sorted.sort((next, pre) => next - pre);
    nums.push(...sorted);
  }
  nums;
};
```
#### 实现[['a', 'b'], ['n', 'm'], ['0', '1']] => ['an0', 'an1, 'am0', 'am1', 'bn0', 'bn1', 'bm0', 'bm1']
```js
function changeArr(arr) {
  // 赋值：赋值给一个新的对象，这样修改之后不会影响之前的值
  const newArr = [...arr];
  // 取值：获取数组的第一个值
  let result = newArr.shift();
  // 循环这个数组
  while (newArr.length) {
    // 取值：从这个数组中再次获取第一个值
    const other = newArr.shift();
    // 定义一个新的数组为 []
    const newResult = [];
    // 循环 result
    result.forEach((item) => {
      // 循环 other
      other.forEach((_item) => {
        // 把数据组合返回给定义的数组
        newResult.push(item + "" + _item);
      });
    });
    // 把 result 赋值给 newResult
    result = [...newResult];
  }
  return result;
}
const arr = [
  ["a", "b"],
  ["m", "n"],
  [0, 1],
];
const result = changeArr(arr);
console.log(result); // ["am0", "am1", "an0", "an1", "bm0", "bm1", "bn0", "bn1"]
const arr2 = [
  ["a", "b"],
  ["m", "n", "0"],
  [0, 1],
  ["#", "$"],
];
const result2 = changeArr(arr2);
console.log(result2);
// (24) ["am0#", "am0$", "am1#", "am1$", "an0#", "an0$", "an1#", "an1$", "a00#", "a00$", "a01#", "a01$", "bm0#", "bm0$", "bm1#", "bm1$", "bn0#", "bn0$", "bn1#", "bn1$", "b00#", "b00$", "b01#", "b01$"]
```
#### 合并区间
```js
//输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
//输出: [[1,6],[8,10],[15,18]]
//解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
var merge = function (intervals) {
  if (intervals.length <= 1) {
    return intervals;
  }

  // 先将数组按照区间最左边的大小顺序排序（升序）
  let arr = intervals.sort((a, b) => a[0] - b[0]);
  function unite(arr, i) {
    if (i == arr.length - 1) {
      return arr;
    }
    // 如果下一个区间的左区间在本区间之间，则合并一次
    if (arr[i + 1][0] <= arr[i][1]) {
      arr[i] = [arr[i][0], Math.max(arr[i][1], arr[i + 1][1])];
      // 合并之后删除冗余区间
      arr.splice(i + 1, 1);
    } else {
      // 如果没有合并，则找到下一个待合并区间
      i++;
    }
    return unite(arr, i);
  }

  return unite(arr, 0);
};
```
#### 两数之和：给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。输入：nums = [2,7,11,15], target = 9 输出：[0,1]
```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (nums, target) {
  for (let i = 0; i < nums.length; i++) {
    let onitem = nums[i];
    let next = nums.indexOf(target - onitem);
    if (next !== -1 && next !== i) {
      return [i, next];
    }
  }
};
```
#### 三数之和：给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。
```js
var threeSum = function (nums) {
  // 如果元素的个数小于4，直接返回空数组
  if (nums.length < 3) {
    return [];
  }
  let res = [];
  nums.sort((num1, num2) => num1 - num2);
  for (let i = 0; i < nums.length - 2; i++) {
    if (i > 0 && nums[i] === nums[i - 1]) {
      continue;
    }
    let left = i + 1;
    let right = nums.length - 1;
    while (left < right) {
      if (nums[i] + nums[left] + nums[right] === 0) {
        if (nums[left] === nums[left + 1] && right > left + 1) {
          left++;
          continue;
        } else if (nums[right] === nums[right - 1] && right > left + 1) {
          right--;
          continue;
        } else {
          res.push([nums[i], nums[left], nums[right]]);
          left++;
        }
      } else if (nums[i] + nums[left] + nums[right] < 0) {
        left++;
      } else {
        right--;
      }
    }
  }
  return res;
};
```
#### [搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
```js
 /**
 * 二分法
 */
public int search(int[] nums, int target) {
    int len = nums.length;
    int left = 0;   // 左边界
    int right = len -1; // 右边界
    while (left <= right) {
        int mid = (right + left) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        // 右半边为升序
        else if (nums[mid] < nums[right]) {
            if (nums[mid] < target && target <= nums[right]) {
                // 如果值在右半边，则丢弃左半边
                left = mid + 1;
            } else {
                // 其他情况
                right = mid - 1;
            }
        }
        // 左半边升序
        else {
            if (nums[left] <= target && target < nums[mid]) {
                // 如果值在左半边，则丢弃右半边
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
    }
    return -1;
}
```
#### [寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)
```js
var findMedianSortedArrays = function (nums1, nums2) {
  let res = [];
  if (nums1.length < 1) {
    res = nums2;
  }
  if (nums2.length < 1) {
    res = nums1;
  }
  res = nums2.concat(nums1);
  res = res.sort((a, b) => a - b);
  let i1 = Math.ceil(res.length / 2);
  let i2 = Math.floor(res.length / 2);
  if (i1 === i2) {
    return (res[i1 - 1] + res[i1]) / 2;
  } else {
    return res[i2];
  }
};
```
#### [全排列](https://leetcode-cn.com/problems/permutations/)
```js
var permute = function (nums) {
  const res = [];

  // 回溯
  const backtrack = (path) => {
    // 终点，当 path 的 length 和 nums 的 length 相等的时候，记录这一次的 path 并结束递归
    if (path.length === nums.length) {
      return res.push(path);
    }

    // 通过循环加递归的形式，模拟出所有的排列情况
    nums.forEach((v) => {
      // 当 path 中，包含这一次的循环的值的时候，进行回溯(中断递归)
      if (path.includes(v)) return;

      // 递归
      backtrack(path.concat(v));
    });
  };
  backtrack([]);

  return res;
};
```
#### [字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)
```js
var firstUniqChar = function (s) {
  for (let i in s) {
    if (s.indexOf(s[i]) == s.lastIndexOf(s[i])) {
      return i;
    }
  }
  return -1;
};
```
#### [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
```js
var lengthOfLongestSubstring = function(s) {
    // 哈希集合，记录每个字符是否出现过
    const occ = new Set();
    const n = s.length;
    // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    let rk = -1, ans = 0;
    for (let i = 0; i < n; ++i) {
        if (i != 0) {
            // 左指针向右移动一格，移除一个字符
            occ.delete(s.charAt(i - 1));
        }
        while (rk + 1 < n && !occ.has(s.charAt(rk + 1))) {
            // 不断地移动右指针
            occ.add(s.charAt(rk + 1));
            ++rk;
        }
        // 第 i 到 rk 个字符是一个极长的无重复字符子串
        ans = Math.max(ans, rk - i + 1);
    }
    return ans;
};
```
[参考原文](https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/227999/)
#### [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)
```js
var longestPalindrome = function (s) {
  let n = s.length;
  if (n == 0) return ""; //字符串为空则返回空
  if (n == 1) return s; //字符串为一个字符, 显然返回自身
  let result = "";
  for (let i = 0; i < n; i++) {
    //字符串长度超过2
    for (let j = i + 1; j <= n; j++) {
      let str = s.slice(i, j); //可得到所有子串
      let f = str.split("").reverse().join(""); //对字符串利用数组方法倒序

      if (str == f) {
        //判断是否为回文
        result = str.length > result.length ? str : result;
      }
    }
  }
  return result;
};
```
#### [整数反转](https://leetcode-cn.com/problems/reverse-integer/)

```js
var reverse = function (x) {
  const symbol = String(x).split("").reverse().join("");
  let result;
  if (x >= 0) {
    result = Number(symbol);
  } else {
    result = Number(symbol.slice(-1) + symbol.slice(0, -1));
  }
  if (result < (-2) ** 31 || result > 2 ** 31 - 1) {
    result = 0;
  }
  return result;
};
```
#### 退格
```js
// 比较含有退格的字符串，"<-"代表退格键，"<"和"-"均为正常字符
// 输入："a<-b<-", "c<-d<-"，结果：true，解释：都为""
// 输入："<-<-ab<-", "<-<-<-<-a"，结果：true，解释：都为"a"
// 输入："<-<ab<-c", "<<-<a<-<-c"，结果：false，解释："<ac" !== "c"
function isEqual(str1, str2) {
  function getResStr(str) {
    let res = [];
    for (let i = 0; i < str.length; i++) {
      if (str[i] === "<" && str[i + 1] === "-") {
        res.pop();
        i++;
      } else {
        res.push(str[i]);
      }
    }
    console.log(res.join(""));
    return res.join("");
  }
  let restBo = getResStr(str1) === getResStr(str2);
  console.log(restBo);
  return restBo;
}
isEqual("a<-b<-", "c<-d<-");
isEqual("<-<-ab<-", "<-<-<-<-a");
isEqual("<-<ab<-c", "<<-<a<-<-c");
```
#### 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合，输入：n = 3，输出：["((()))","(()())","(())()","()(())","()()()"]
```js
function generateParenthesis(n: number): string[] {
  const result: string[] = [];
  const dfs = (path: string, count1: number, count2: number) => {
    // path为递归的字符串，count1为左括号的数量，count2为右括号的数量
    // 当左括号或右括号大于传入的n，括号生成后的岁数，那这个递归函数就不跑了。
    if (count1 > n || count2 > n) return;
    // 如果右括号的数量大于左括号的数量，也不符合题意，也不跑了。
    if (count2 > count1) return;
    // 左括号和右括号的数量都对了 那就把正确结果推出去
    if (count1 === n && count2 === n) {
      result.push(path);
      return;
    }

    //这边处理第一次传入空字符串的情况
    if (count1 === 0) {
      dfs(path + "(", count1 + 1, count2);
    } else {
      // 只有这两种结果
      dfs(path + "(", count1 + 1, count2);
      dfs(path + ")", count1, count2 + 1);
    }
  };
  dfs("", 0, 0);
  return result;
}
```
#### [有效括号](https://leetcode-cn.com/problems/valid-parentheses/)
```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
  let sObj = {
    "(": ")",
    "[": "]",
    "{": "}",
  };
  let que = [];
  for (let i = 0; i < s.length; i++) {
    if (que.length === 0) {
      que.push(s[i]);
    } else if (sObj[que[que.length - 1]] === s[i]) {
      que.pop();
    } else {
      que.push(s[i]);
    }
  }
  if (que.length === 0) {
    return true;
  } else {
    return false;
  }
};
```
#### [数组中出现次数超过一半的数字](https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/)
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function (nums) {
  let newNums = nums.sort((a, b) => a - b);
  let length = Math.floor(newNums.length / 2);
  for (let i = 0; i < length + 1; i++) {
    if (newNums[i] === newNums[i + length]) {
      return newNums[i];
    }
  }
  return -1;
};
```
#### 返回该数组中出现频率>=n 的元素列表
```js
Array.prototype.findDup = function (count) {
  return this.reduce((re, val) => {
    let index = re.findIndex((o) => o.val === val);
    if (index >= 0) {
      re[index].count++;
    } else {
      re.push({ count: 1, val });
    }
    return re;
  }, [])
    .filter((o) => o.count >= count)
    .map((o) => o.val);
};
```
#### 对象查找值，返回路径
```js
let obj = {
    a: {
        a_1: {
            a_1_1: 'a11',
            a_1_2: 'a12'
        },
        a_2: {
            a_2_1: 'a21',
            a_2_2: 'a22'
        }
    },
    b: {
        b_1: 'b1',
        b_2: 'b2'
    },
    c: 'c'
} 
function findPath(obj, val) {
    let keys = Object.keys(obj);
    let result = [];
    for (let i = 0; i < keys.length; i++) {
        let _ = keys[i];
        if (typeof obj[_] === 'object' && obj[_] !== null) {
            let res = findPath(obj[_], val);
            if (res.length > 0) {
                result = result.concat([_], res);
            }
        } else if (obj[_] === val) {
            result = result.concat([_]);
            break;
        }
    }
    return result;
}
console.log(findPath(obj, 'a22')); // ['a', 'a_2', 'a_2_2']
```
#### [最多能完成排序的块](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/description/)
```js
var maxChunksToSorted = function(arr) {
    const stack = [];
    for (const num of arr) {
        if (stack.length === 0 || num >= stack[stack.length - 1]) {
            stack.push(num);
        } else {
            const mx = stack.pop();
            while (stack.length && stack[stack.length - 1] > num) {
                stack.pop();
            }
            stack.push(mx);
        }
    }
    return stack.length;
};
```
[参考原文](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solutions/1741851/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-w5c6/)
#### [超级回文数](https://leetcode.cn/problems/super-palindromes/description/)
```js
var superpalindromesInRange = function(left, right) {
  let ans = []; 
  // 从 1 开始构造回文数
  // 因为最大就是20位数，所以这里构造回文数肯定不会超 100000
  for(let i = 1; i < 100000; i++) {
    let [p1, p2] = makePalindromes(i);
    let pp1 = BigInt(p1 * p1);
    let pp2 = BigInt(p2 * p2);
    if(pp1 >= left && pp1 <= right && checkPalindromes(pp1)) {
      ans.push(pp1.toString());
    }
    if(pp2 >= left && pp2 <= right && checkPalindromes(pp2)) {
      ans.push(pp2.toString());
    }
  }
  ans.sort((a, b) => a - b);
  return ans;
};

let checkPalindromes = function(num) {
  return Array.from(num.toString()).reverse().join("") === num.toString()
};

//  构造奇数、偶数回文数
let makePalindromes = function(num) {
  let numStr = num.toString();
  let revNumStr = Array.from(numStr).reverse().join("");
  return [BigInt(numStr + revNumStr), BigInt(numStr + revNumStr.slice(1))]
};
```
[参考原文](https://leetcode.cn/problems/super-palindromes/solutions/1711358/js-by-a-ba-li-9fcy/)
#### [最长超赞子字符串](https://leetcode.cn/problems/find-longest-awesome-substring/description/)
```js
var longestAwesome = function(s) {
    let prefix = new Map([[0, -1]]);
    let ans = 0;
    let sequence = 0;
    for (let j = 0; j < s.length; ++j) {
        let digit = parseInt(s[j]);
        sequence ^= (1 << digit);
        if (prefix.has(sequence)) {
            ans = Math.max(ans, j - prefix.get(sequence));
        } else {
            prefix.set(sequence, j);
        }
        for (let k = 0; k < 10; ++k) {
            if (prefix.has(sequence ^ (1 << k))) {
                ans = Math.max(ans, j - prefix.get(sequence ^ (1 << k)));
            }
        }
    }
    return ans;
};
```
[参考原文](https://leetcode.cn/problems/find-longest-awesome-substring/solutions/379067/zhao-chu-zui-chang-de-chao-zan-zi-zi-fu-chuan-by-l/)
#### [拼接最大数](https://leetcode.cn/problems/create-maximum-number/description/)
```js
var maxNumber = function (nums1, nums2, k) {
  let max = null
  for (let i = 0; i <= k; i++) {
    if (k - i > nums2.length) continue
    if (i > nums1.length) continue
    const list1 = helper(nums1, i)
    const list2 = helper(nums2, k - i)
    const current = compose(list1, list2)
    if (max) {
      max = computMaxArray(max, current)
    } else {
      max = current
    }
  }
  return max

  function computMaxArray(ary1, ary2) {
    if (ary1.length === 0) return ary2
    if (ary2.length === 0) return ary1
    if (ary1.length > ary2.length) return ary1
    if (ary1.length < ary2.length) return ary2
    let index = 0
    while (index < ary1.length) {
      if (ary1[index] > ary2[index]) {
        return ary1
      } else if (ary1[index] < ary2[index]) {
        return ary2
      }
      index++
    }
    return ary2
  }
  // 找到数组1和2谁大
  function check(a1, index1, a2, index2) {
    while (index1 < a1.length && index2 < a2.length) {
      const diff = a1[index1] - a2[index2]
      if (diff !== 0) return diff
      index1++
      index2++
    }
    return a1.length - index1 - (a2.length - index2)
  }

  // 合并两个有序数组
  function compose(ary1, ary2) {
    const list = []
    const len1 = ary1.length
    const len2 = ary2.length
    let index1 = 0
    let index2 = 0
    for (let i = 0; i < len1 + len2; i++) {
      if (check(ary1, index1, ary2, index2) > 0) {
        list[i] = ary1[index1++]
      } else {
        list[i] = ary2[index2++]
      }
    }
    return list
  }
  function helper(array, limit) {
    if (limit === 0) return []
    if (limit >= array.length) return array
    const stack = []
    let index = 0
    const len = array.length
    while (index < len) {
      while (
        stack.length &&
        stack[stack.length - 1] < array[index] &&
        stack.length + len - index - 1 >= limit
      ) {
        stack.pop()
      }
      stack.push(array[index++])
    }
    return stack.slice(0, limit)
  }
}
```
#### [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)
```js
/**
 * @param {number[]} height
 * @return {number}
*/
var maxArea = function(height) {
    let ans = 0
    let left = 0, right = height.length-1
    while(left<right) {
        let area = (right-left) * Math.min(height[left], height[right])
        ans = Math.max(area, ans)
        if(height[left]<=height[right]) {
            left++
        } else {
            right--
        }
    }
    return ans
};
```
#### [接雨水](https://leetcode.cn/problems/trapping-rain-water/)
```js
/**
 * @param {number[]} height
 * @return {number}
*/
var trap = function(height) {
    let ans = 0;
    let left = 0, right = height.length - 1;
    let leftMax = 0, rightMax = 0;
    while(left<right) {
        leftMax = Math.max(leftMax, height[left]);
        rightMax = Math.max(rightMax, height[right]);
        if(height[left]<height[right]) {
            ans += leftMax-height[left];
            left ++;
        } else {
            ans += rightMax-height[right];
            right--;
        }
    }
    return ans;
};
```
[参考原文](https://juejin.cn/post/7071584649142599693)
#### [岛屿最大面积](https://leetcode.cn/problems/max-area-of-island/description/)
```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var maxAreaOfIsland = function(grid) {
  var max=0;
  for (var i = 0; i < grid.length; i++) {
    for (var j = 0; j < grid[0].length; j++) {
      if (grid[i][j] === 1) {
         max = Math.max(max, island(grid, i, j));
      } 
    }
  }
  return max;
};
 
var island = function(grid, i, j) {
  if (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length && grid[i][j] === 1) {
    grid[i][j] = 0;
    return 1 + island(grid, i+1, j) + island(grid, i-1, j) + island(grid, i, j+1) + island(grid, i, j-1);
  } else return 0;
}
```
[参考原文](https://blog.csdn.net/romeo12334/article/details/81410531)
#### [解码异或后的排列](https://leetcode.cn/problems/decode-xored-permutation/description/)
```js
var decode = function(encoded) {
    const n = encoded.length + 1;
    let total = 0;
    for (let i = 1; i <= n; i++) {
        total ^= i;
    }
    let odd = 0;
    for (let i = 1; i < n - 1; i += 2) {
        odd ^= encoded[i];
    }
    const perm = new Array(n).fill(0);
    perm[0] = total ^ odd;
    for (let i = 0; i < n - 1; i++) {
        perm[i + 1] = perm[i] ^ encoded[i];
    }
    return perm;
};
```
[参考原文](https://leetcode.cn/problems/decode-xored-permutation/solutions/769140/jie-ma-yi-huo-hou-de-pai-lie-by-leetcode-9gw4/)
## 链表
#### 线性表
Linear List，是n个数据元素的有限序列。
在数据结构逻辑层次上细分，线性表可分为一般线性表和受限线性表。一般线性表也就是我们通 常所说的“线性表”，可以自由的删除或添加结点。受限线性表主要包括栈和队列，受限表示对 结点的操作受限制。
我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以双向链表和循环链 表依旧是线性表。
#### 存储结构
顺序表：是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的存储单元依次存储数据元 素的线性结构，使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通 过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。
链表：Linked list，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一 个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比 另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而 顺序表相应的时间复杂度分别是O(logn)和O(1)。
使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内 存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了 结点的指针域，空间开销比较大。
单链表：即单向链表，特点是链表的链接方向是单向的，对链表的访问要通过从头部开始，依序往下读 取。React中有个典型的应用场景就是Fiber children。
双链表：即双向链表，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向 链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。
循环链表：最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和单链表的操 作基本一致，差别仅仅在于算法中的循环条件有所不同。循环链表根据单向与双向，又可以分为单向循环链表与双向环形链表。
![链表](https://github.com/lujiajian1/study-notes/blob/main/img/linked.jpg)
#### 链表（插入，删除，反转）
```js
//节点类
class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

class SinglyLinkedList {
  constructor(data) {
    this.head = new Node(data);
  }
  add(data) {
    let node = new Node(data);
    let current = this.head;
    while (current.next) {
      current = current.next;
    }
    current.next = node;
  }
  addAt(data, index) {
    let node = new Node(data);
    let current = this.head;
    let currentIndex = 1;
    while (currentIndex < index) {
      current = current.next;
      currentIndex++;
    }
    node.next = current.next;
    current.next = node;
  }
  removeAt(index) {
    let current = this.head;
    let currentIndex = 1;
    let pre = null;
    while (currentIndex < index) {
      pre = current;
      current = current.next;
      currentIndex++;
    }
    pre.next = current.next;
  }
  reverse() {
    let pre = this.head;
    let current = this.head.next;
    pre.next = null;
    while (current) {
      let next = current.next;
      current.next = pre;
      pre = current;
      current = next;
    }
    this.head = pre;
  }
}
```
#### 判断回文链表
```js
var isPalindrome = function (head) {
  let left = head;
  function traverse(right) {
    if (right == null) return true;
    let res = traverse(right.next);
    res = res && right.val === left.val;
    left = left.next;
    return res;
  }
  return traverse(head);
};
```
#### K 个一组翻转链表（输入：head = [1,2,3,4,5], k = 2 ; 输出：[2,1,4,3,5]）
```js
var reverseKGroup = function (head, k) {
  let a = head,
    b = head;
  for (let i = 0; i < k; i++) {
    if (b == null) return head;
    b = b.next;
  }
  const newHead = reverse(a, b);
  a.next = reverseKGroup(b, k);
  return newHead;
};
function reverse(a, b) {
  let prev = null,
    cur = a,
    nxt = a;
  while (cur != b) {
    nxt = cur.next;
    cur.next = prev;
    prev = cur;
    cur = nxt;
  }
  return prev;
}
```
#### 判断环形链表
```js
var hasCycle = function (head) {
  if (head == null || head.next == null) return false;
  let slower = head,
    faster = head;
  while (faster != null && faster.next != null) {
    slower = slower.next;
    faster = faster.next.next;
    if (slower === faster) return true;
  }
  return false;
};
```
#### 判断相交链表
```js
var getIntersectionNode = function (headA, headB) {
  let lastHeadA = null;
  let lastHeadB = null;
  let originHeadA = headA;
  let originHeadB = headB;
  if (!headA || !headB) {
    return null;
  }
  while (true) {
    if (headB == headA) {
      return headB;
    }
    if (headA && headA.next == null) {
      lastHeadA = headA;
      headA = originHeadB;
    } else {
      headA = headA.next;
    }
    if (headB && headB.next == null) {
      lastHeadB = headB;
      headB = originHeadA;
    } else {
      headB = headB.next;
    }
    if (lastHeadA && lastHeadB && lastHeadA != lastHeadB) {
      return null;
    }
  }
  return null;
};
```
#### 合并两个有序链表
```js
//输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4
var mergeTwoLists = function (l1, l2) {
  if (l1 == null) return l2;
  if (l2 == null) return l1;
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
};
```
#### [合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
```js
/**
 * @param {ListNode[]} lists
 * @return {ListNode}
*/
var mergeKLists = function(lists) {
    const k = lists.length;
    if(k==0) {
        return null;
    }
    if(k===1) {
        return lists[0];
    }
    let dummyNode = current = {next: null};
    let min;
    let minI;
    const a = new Array(k).fill(0);
    while(1) {
        if(a.reduce((x,y)=>x+y)===k) {
            break;
        }
        minI = 0;
        min = Math.pow(-10, 4) - 1;
        for(let i=0; i<k; i++) {
            if(a[i]===1) {
                continue;
            }
            let cur = lists[i];
            if(cur==null) {
                a[i] = 1;
                continue;
            }
            if(min>cur.val) {
                min = cur.val;
                minI = i;
            }
        }
        if(min!==Math.pow(-10, 4) - 1) {
            current.next = lists[minI];
            current = current.next;
            lists[minI] = lists[minI].next;
            if(lists[minI]==null) {
                a[minI] = 1;
            }
        }
    }
    return dummyNode.next;
};
```
#### [两数相加](https://leetcode-cn.com/problems/add-two-numbers/)
```js
var addTwoNumbers = function (l1, l2) {
  let addOne = 0;
  let sum = new ListNode("0");
  let head = sum;
  while (addOne || l1 || l2) {
    let val1 = l1 !== null ? l1.val : 0;
    let val2 = l2 !== null ? l2.val : 0;
    let r1 = val1 + val2 + addOne;
    addOne = r1 >= 10 ? 1 : 0;
    sum.next = new ListNode(r1 % 10);
    sum = sum.next;
    if (l1) l1 = l1.next;
    if (l2) l2 = l2.next;
  }
  return head.next;
};
```
## 栈/队列
stack，又叫堆栈。一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。常见 操作：进栈、出栈。
队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行 插入操作，和栈一样，队列是一种操作受限制的线性表。 
队列是先进先出，栈是先进后出。
#### [有效括号](https://leetcode.cn/problems/valid-parentheses/)
```js
/**
 * 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。有效字符串需满足：1.左括号必须用相同类型的右括号闭合。2.左括号必须以正确的顺序闭合。3.每个右括号都有一个对应的相同类型的左括号。
 * @param {string} s
 * @return {boolean}
*/
function isLeft (char) {
    return char === '(' || char === '[' || char === '{';
}
var isValid = function(s) {
    const len = s.length;
    if(len%2===1) {
        return false;
    }
    const stack = [ s[0] ];
    for(let i=1; i<len; i++) {
        let char = s[i];
        if(isLeft(char)) {
            stack.push(char);
            continue;
        }
        let prev = stack.pop();
        if((prev==='(' && char===')') || (prev==='[' && char===']') || (pr ev==='{' && char==='}')) {
            continue;
        } else {
            return false;
        }
    }
    return stack.length===0;
}
```
#### [最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)
```js
/**
 * 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。
 * @param {string} s
 * @return {number}
*/
var longestValidParentheses = function(s) {
    let len = s.length;
    if(len<=1) {
        return 0;
    }
    let maxlen = 0;
    const stack = [-1];
    for(let i=0;i<len;i++) {
        if(s[i]==='(') {
            stack.push(i);
        } else {
            stack.pop();
            let stack_len = stack.length;
            if(stack_len===0) {
                stack.push(i);
            } else {
                maxlen = Math.max(maxlen, i - stack[stack_len-1]);
            }
        }
    }
    return maxlen;
};
```
#### [函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/)
```js
var exclusiveTime = function(n, logs) {
    const len = logs.length;
    const res = new Array(n).fill(0);
    const stack = [];
    let s = logs[0].split(':');
    let prev = s[0];
    let i = 1;
    stack[0] = s[0];
    while(i<len) {
        s = logs[i].split(':');
        if(s[1]==='start') {
            res[ stack[stack.length-1] ] += s[2] - prev;
            stack.push(s[0]) prev = s[2];
        } else {
            const tem = stack.pop();
            res[tem] += s[2] - prev + 1;
            prev = s[2] - 0 + 1;
        }
        i++;
    }
    return res;
}
```
#### [用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)
```js
var CQueue = function() {
    this.inStack = [];
    this.outStack = [];
};
/** 
 * @param {number} value
 * @return {void}
*/
CQueue.prototype.appendTail = function(value) {
    this.inStack.push(value)
};
/**
 * @return {number}
*/
CQueue.prototype.deleteHead = function() {
    if (this.outStack.length===0) {
        if (this.inStack.length===0) {
            return -1;
        } else {
            this.in2out();
        }
    }
    return this.outStack.pop();
};
CQueue.prototype.in2out = function() {
    while (this.inStack.length) {
        this.outStack.push(this.inStack.pop());
    }
};
```
## 二叉树
#### 资源
[LeetCode介绍](https://leetcode.cn/tag/tree/problemset/)
[维基百科](https://zh.m.wikipedia.org/zh-hans/树_(数据结构))
#### 树
tree，是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状 结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫 做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：
* 每个节点都只有有限个子节点或无子节点；
* 没有父节点的节点称为根节点；
* 每一个非根节点有且只有一个父节点；
* 除了根节点外，每个子节点可以分为多个不相交的子树；
* 树里面没有环路(cycle)。
![树](https://github.com/lujiajian1/study-notes/blob/main/img/tree.jpg)
#### 常见术语
1. 节点的度：一个节点含有的子树的个数称为该节点的度；
2. 树的度：一棵树中，最大的节点度称为树的度；
3. 叶节点或终端节点：度为零的节点；
4. 非终端节点或分支节点：度不为零的节点；
5. 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
6. 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
7. 兄弟节点：具有相同父节点的节点互称为兄弟节点；
8. 节点的层次（深度、高度)：从根开始定义起，根为第1层，根的子节点为第2层，以此类 推；
9. 深度： 对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
10. 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
11. 节点的祖先：从根到该节点所经分支上的所有节点；
12. 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
13. 森林：由m（m>=0）棵互不相交的树的集合称为森林；
#### 树的种类
* 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树。
* 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
    * 二叉树：每个节点最多含有两个子树的树称为二叉树；
        * 完全二叉树：对于一棵二叉树，假设其深度为d（d>1）。除了第d层外，其它各层的 节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树 被称为完全二叉树；
        * 满二叉树：所有叶节点都在最底层的完全二叉树；
        * 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；
        * 排序二叉树(二叉查找树（英语：Binary Search Tree))：也称二叉搜索树、有序二叉 树；
    * 霍夫曼树、哈夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；
    * B树：一种对读写操作进行优化的平衡查找树。
#### 二叉树
是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。
#### 满二叉树
除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 从图形形态上看，满二叉树外观上是一个三角形。 如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。 
![树](https://github.com/lujiajian1/study-notes/blob/main/img/tree1.jpg)
注意： 关于满二叉树定义这里，国内外定义有分歧，本文采用的是国内定义。满二叉树英文是 Full Binary Tree，是指所有的节点的度只能是0或者2。 如下图，国外也认为是Full Binary Tree：
![树](https://github.com/lujiajian1/study-notes/blob/main/img/tree2.jpg)
而对于我们本文所说的满二叉树，国外的概念叫完美二叉树。
#### 完全二叉树
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如 果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树 称为完全二叉树。叶子结点只可能在最大的两层出现。
#### 二叉树前中后遍历
![二叉树前中后遍历](https://github.com/lujiajian1/study-notes/blob/main/img/nodetree.png)
```js
// 二叉树的生成
function NodeTree(value){
    this.value = value;
    this.left = null;
    this.right = null;
}

let ta = new NodeTree('a');
let tb = new NodeTree('b');
let tc = new NodeTree('c');
let td = new NodeTree('d');
let te = new NodeTree('e');
let tf = new NodeTree('f');
let tg = new NodeTree('g');

ta.left = tb;
ta.right = tc;
tb.left = td;
tb.right = te;
tc.left = tf;
tc.right = tg;

// 形如上面的这个格式，ta被称为一颗二叉树。 满二叉树， 完全二叉树

// 二叉树的遍历，分为三种，前序遍历，中序遍历，后续遍历（使用回调）
/**
 * 二叉树的前序遍历
 * @param treeList
 * @returns {null}
 */
function treeFrontEach(treeList){
    if (!treeList || treeList.value === null) return null;
    console.log(treeList.value);
    treeFrontEach(treeList.left);
    treeFrontEach(treeList.right);
}

treeFrontEach(ta); 输出的结果 a b d e c f g

/**
 * 中序遍历
 * @param treeList
 * @returns {null}
 */
function treeMiddleEach(treeList){
    if (!treeList || treeList.value === null) return null;
    treeMiddleEach(treeList.left);
    console.log(treeList.value);
    treeMiddleEach(treeList.right);
}
treeMiddleEach(ta); 输出的结果 d b e a c f c g

/**
 * 后序遍历
 * @param treeList
 * @returns {null}
 */
function treeEndEach(treeList){
    if (!treeList || treeList.value === null) return null;
    treeEndEach(treeList.left);
    treeEndEach(treeList.right);
    console.log(treeList.value);
}

treeEndEach(ta); 输出结果 d e b f g c a
```
```js
//不使用回调

//前序遍历
const preorderTraversal = function (root) {
  const stack = [],
    res = [];
  root && stack.push(root);
  // 使用一个栈stack，每次首先输出栈顶元素，也就是当前二叉树根节点，之后依次输出二叉树的左孩子和右孩子
  while (stack.length > 0) {
    let cur = stack.pop();
    res.push(cur.val);
    // 先入栈的元素后输出，所以先入栈当前节点右孩子，再入栈左孩子
    cur.right && stack.push(cur.right);
    cur.left && stack.push(cur.left);
  }
  return res;
};
//中序遍历
const inorderTraversal = function (root) {
  const res = [],
    stack = [];
  let node = root;
  while (stack.length > 0 || node !== null) {
    if (node) {
      //node存在
      stack.push(node); //当前节点push
      node = node.left; //找left
    } else {
      //node不存在
      node = stack.pop(); //弹出最深的left
      res.push(node.val); //res push
      node = node.right; //找right
    }
  }
  return res;
};
//后序遍历
const postorderTraversal = function (root) {
  let stack = [],
    res = [];
  root && stack.push(root);
  while (stack.length > 0) {
    let cur = stack.pop();
    res.push(cur.val);
    cur.left && stack.push(cur.left);
    cur.right && stack.push(cur.right);
  }
  return res.reverse();
};
```
#### 判断对称二叉树（镜像对称）
```js
// 用于递归的helper函数，接收参数为左节点和右节点。
const helper = (left: TreeNode | null, right: TreeNode | null) => {
  // 如果传入的左节点和右节点都不存在 也是镜像
  if (left == right) return true;
  // 如果左节点和右节点有一个的值不存在，那就不是对称的两个节点
  else if (left.val === 0 || right.val === 0) return false;
  // 最后判断并递归，左节点和右节点都存在并且值为相等，那就递归他们的子节点。
  return (
    left.val === right.val &&
    helper(left.left, right.right) &&
    helper(left.right, right.left)
  );
};
function isSymmetric(root: TreeNode | null): boolean {
  //传入的root可能为null，做下判断。
  if (root === null || root === undefined) return true;
  else {
    return helper(root.left, root.right);
  }
}
```
#### [平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)
```js
function isBalanced(root) {
  if (root === null) {
    return true;
  }
  return (
    Math.abs(tree_height(root.left) - tree_height(root.right)) <= 1 &&
    isBalanced(root.left) &&
    isBalanced(root.right)
  );
}
function tree_height(root) {
  var deep = -Infinity;
  if (root === null) {
    return -1;
  }
  deep = Math.max(deep, tree_height(root.left));
  deep = Math.max(deep, tree_height(root.right));
  return deep + 1;
}
```
#### [路径总和](https://leetcode-cn.com/problems/path-sum/submissions/)
```js
//通过递归方法来解决
var hasPathSum = function (root, targetSum) {
  if (!root) {
    return false;
  }
  if (root.val == targetSum && root.left == null && root.right == null) {
    return true;
  }
  let left = hasPathSum(root.left, targetSum - root.val);
  let right = hasPathSum(root.right, targetSum - root.val);
  return left || right;
};
```
#### [路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)
```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function (root, targetSum) {
  var res = [];
  var array = [];
  function doFind(root, targetSum) {
    if (root == null) return;
    targetSum = targetSum - root.val;
    array.push(root.val);
    if (root.left == null && root.right == null && targetSum == 0) {
      res.push([...array]);
    }
    doFind(root.left, targetSum);
    doFind(root.right, targetSum);
    array.pop();
  }
  doFind(root, targetSum);
  return res;
};
```
#### [翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
  if (root) {
    [root.left, root.right] = [invertTree(root.right), invertTree(root.left)];
  }
  return root;
};
```
#### [合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)
```js
var mergeTrees = function (t1, t2) {
  if (!t1) return t2;
  if (!t2) return t1;
  t1.val = t1.val + t2.val;
  t1.left = mergeTrees(t1.left, t2.left);
  t1.right = mergeTrees(t1.right, t2.right);
  return t1;
};
```
#### DOM 树的 DFS(深度优先遍历)
```js
const parentDOM = document.querySelector("#container");
//非回调
function deepTravalSal(node) {
  const nodes = [];
  const stack = [];
  if (node) {
    stack.push(node);
    while (stack.length) {
      const item = stack.pop();
      const len = item.children.length;
      nodes.push(item);
      for (let i = len - 1; i >= 0; i--) {
        stack.push(item.children[i]);
      }
    }
  }
  return nodes;
}
//回调
function dfs(dom) {
  let nodeList = [];
  nodeList.push(dom);
  if (dom.children && dom.children.length) {
    for (let i = 0; i < dom.children.length; i++) {
      nodeList = nodeList.concat(dfs(dom.children[i]));
    }
  }
  return nodeList;
}
console.log(deepTravalSal(parentDOM));
```
#### DOM 树的 BFS(广度优先遍历)
```js
const parentDOM = document.getElementById("container");
//非回调
function breathTravalSal(node) {
  const nodes = [];
  const queue = [];
  if (node) {
    queue.push(node);
    while (queue.length) {
      const item = queue.shift();
      nodes.push(item);
      for (const v of item.children) {
        queue.push(v);
      }
    }
  }
  return nodes;
}
//回调
function bfs(dom) {
  if (!(dom instanceof Array)) {
    dom = [dom];
  }
  let nodeList = [];
  let childrenArr = [];
  for (let i = 0; i < dom.length; i++) {
    nodeList.push(dom[i]);
    if (dom[i].children && dom[i].children.length) {
      childrenArr = childrenArr.concat(dom[i].children);
    }
  }
  if (childrenArr.length > 0) {
    nodeList = nodeList.concat(bfs(childrenArr));
  }
  return nodeList;
}
console.log(breathTravalSal(parentDOM));
```
#### [二叉树右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
```js
//方法1
var rightSideView = function (root) {
  if (!root) return [];
  let arrList = [];
  DFS(root, 0, arrList);
  return arrList;
};

function DFS(root, depth, res) {
  if (root) {
    if (res.length === depth) {
      // 当数组长度等于当前 深度 时, 把当前的值加入数组
      res.push(root.val);
    }
    DFS(root.right, depth + 1, res); // 先从右边开始, 当右边没了, 再轮到左边
    DFS(root.left, depth + 1, res);
  }
}
//方法2
var rightSideView = function(root) {
    let nums = [];
    if (!root) return nums;

    let stack = [];
    let p = root;
    let maxDepth = 0;
    let currentDepth = 0;
    while(p || stack.length > 0) {
        while(p) {      //遍历节点的右分支
            currentDepth++;
            if (currentDepth > maxDepth) {    //推入节点
                maxDepth++;
                nums.push(p.val);
            }
            stack.push([p, currentDepth]);
            p = p.right;
        }

        let node = stack.pop();    //回溯
        p = node[0].left;     //对节点的左分支进行遍历
        currentDepth = node[1];  //当前深度也要回溯
    }

    return nums;
};
```
## 堆
#### 最小堆
是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于其左子节点和右子节点的 值。
![树](https://github.com/lujiajian1/study-notes/blob/main/img/tree3.jpg)
#### 最大堆
最大值在根节点，任意节点值总是大于该子树的最大值，而最小堆则相反
```js
/**
 * 二叉树的最大深度 https://leetcode.cn/problems/maximum-depth-of-binary-tree/
*/
var maxDepth = function(root) {
    if(root===null) {
        return 0;
    }
    return 1 + Math.max( maxDepth(root.left), maxDepth(root.right));
};
```
```js
/**
 * 数据流中的第K大元素
*/
var KthLargest = function(k, nums) {
    this.k = k;
    this.heap = new MinHeap();
    for (const x of nums) {
        this.add(x);
    }
};

KthLargest.prototype.add = function(val) {
    this.heap.offer(val);
    if (this.heap.size() > this.k) {
        this.heap.poll();
    }
    return this.heap.peek();
};

class MinHeap {
    constructor(data = []) {
        this.data = data;
        this.comparator = (a, b) => a - b;
        this.heapify();
    }

    heapify() {
        if (this.size() < 2) return;
        for (let i = 1; i < this.size(); i++) {
        this.bubbleUp(i);
        }
    }

    peek() {
        if (this.size() === 0) return null;
        return this.data[0];
    }

    offer(value) {
        this.data.push(value);
        this.bubbleUp(this.size() - 1);
    }

    poll() {
        if (this.size() === 0) {
            return null;
        }
        const result = this.data[0];
        const last = this.data.pop();
        if (this.size() !== 0) {
            this.data[0] = last;
            this.bubbleDown(0);
        }
        return result;
    }

    bubbleUp(index) {
        while (index > 0) {
            const parentIndex = (index - 1) >> 1;
            if (this.comparator(this.data[index], this.data[parentIndex]) < 0) {
                this.swap(index, parentIndex);
                index = parentIndex;
            } else {
                break;
            }
        }
    }

    bubbleDown(index) {
        const lastIndex = this.size() - 1;
        while (true) {
            const leftIndex = index * 2 + 1;
            const rightIndex = index * 2 + 2;
            let findIndex = index;
            if (
                leftIndex <= lastIndex &&
                this.comparator(this.data[leftIndex], this.data[findIndex]) < 0
            ) {
                findIndex = leftIndex;
            }
            if (
                rightIndex <= lastIndex &&
                this.comparator(this.data[rightIndex], this.data[findIndex]) < 0
            ) {
                findIndex = rightIndex;
            }
            if (index !== findIndex) {
                this.swap(index, findIndex);
                index = findIndex;
            } else {
                break;
            }
        }
    }

  swap(index1, index2) {
        [this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]];
    }

    size() {
        return this.data.length;
    }
}
```
## 动态规划
Dynamic Programming，简称DP，是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。通常会有暴力解决以及优化解决方案，二者用时差别较大。
#### 递推
递推是按照一定的规律来计算序列中的每个项，通常是通过计算前面的一些项来得出序列中的指定项的值。其思想是把一个复杂的庞大的计算过程转化为简单过程的多次重复，该算法利用了计算机速度快和不知疲倦的机器特点。
#### 递推关系式
递推关系（Recurrence relation），在数学上也就是差分方程（Difference equation），是一种递推地定义一个序列的方程：序列的每一项目是定义为前若干项的函数。像斐波那契数即为递推关系：
```math
\chi _{n+2} = \chi _{n=1} + \chi _{n}
```
#### 与递归的区别
Recursion，指程序调用自身的编程技巧。有递推使用上有一定的交叉点。
#### 递推套路总结 
遇到大数据量的题，不知道从哪里下手，通常离不开递归与递推公式。 
原则：大事化小小事化了
1. 找隐藏条件，理解题意。 
2. 找极值，比如0或者1的情况下结果是多少。 
3. 拆解找规律，写公式，（缩小数据范围）。
f(m,n) = f(m-n, n) + f(m, n-1) 
1. 所有盘子放满了，f(m-n, n) 
2. 有1个盘子空着，f(m, n-1)
#### 与递推、递归
动态规划，通常离不开递推公式、递归。
#### 与数学
求值单个数值的dp题，通常会有数学公式求解法，当然这个需要较高的数学功底，这个通常在竞赛中常见，但是面试一般不做要求，面试中更多考察dp的优化版解法。
#### 动态规划解题套路
1. 大事化小：其实就是把大问题拆解成小问题，多会用到递归。其实就是求状态转移方程。
2. 小事化了：设置边界条件或者求初始值，如n=0时，答案值？
3. 优化：记忆求值、有效求值等：暴力求解时间复杂度通常 \>=O(n^2)。因此经常需要优化，记忆求值经常用到数组和Map，有效求值经常用到二分查找。
#### 斐波那契数列
```js
/**
 * 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的 定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1。斐波那契数列由 0 和 1 开始，之 后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 * @param {number} n 
 * @return {number}
*/
var fib = function(n) {
    const arr = [0, 1];
    for(let i=2; i<=n; i++) {
        arr[i] = arr[i-1] + arr[i-2];
        arr[i] %= (1e9+7);
    }
    return arr[n];
}
```
#### 爬楼梯
```js
/**
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 * @param {number} n
 * @return {number} 
*/ 
var climbStairs = function(n) {
    if(n<=3) {
        return n;
    }
    // n>=4 
    //return climbStairs(n-1) + climbStairs(n-2)
    let a = [0, 1, 2, 3];
    for(let i=4; i<n; i++) {
        a[i] = a[i-1] + a[i-2];
    }
    return a[n-1] + a[n-2];
};
```
#### [使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
```js
/**
 * 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支 付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。
*/
var minCostClimbingStairs = function (cost) {
    const len = cost.length;
    let prev = 0, current = 0, next;
    for (let i = 2; i <= len; i++) {
        next = Math.min(current + cost[i - 1], prev + cost[i - 2]);
        prev = current;
        current = next;
    }
    return current;
};
```
#### 放苹果
```c++
/**
 * 把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？ （用K表示）5，1，1和1，5，1 是同一种分法。 1<=M，N<=10。
*/
// 简版
#include <iostream>
using namespace std;
int recursion(int m, int n) {//m个苹果， n个盘子 [1,10]
    if(m<0) return 0;
    if(m==0 || n==1) return 1;
    // 1. 每个盘子放置一个苹果
    // 2. 1个盘子空着，也就是m个苹果放到n-1个盘子里
    return recursion(m-n, n) + recursion(m, n-1); 
}
int main() {
    int t;
    int m, n;
    cin>>t;//[0,20]
    while(t--) {
        cin>>m>>n;
        cout<<dp(m, n)<<endl;
    }
    return 0;
}
```
```c++
// 优化版
#include <iostream>
using namespace std;
int recursion(int m, int n) {//m个苹果， n个盘子 [1,10]
    if(m==1 || n==1) return 1;
    if(n>m) n = m;
    //1个和2个盘子的方法
    int k = 1 + (m>>1);
    // i个盘子，逐个递加
    for(int i=3; i<=n; i++) {
        if(m==i) k++;
        else k += recursion(m-n, i);
    }
    return k;
}
int main() {
    int t;
    int m, n;
    cin>>t;//[0,20]
    while(t--) {
        cin>>m>>n;
        cout<<recursion(m, n)<<endl;
    }
    return 0;
}
```
#### [买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/submissions/)
```js
var maxProfit = function (prices) {
  if (prices.length === 0 || prices.length === 1) {
    return 0;
  }
  // dp1数组存储第`i`天，持有股票的最大利润
  const dp1 = [];
  dp1[0] = -prices[0];
  // dp2数组存储第`i`天，不持有股票的最大利润
  const dp2 = [];
  dp2[0] = 0;

  for (let i = 1; i < prices.length; i++) {
    dp1[i] = Math.max(dp1[i - 1], -prices[i]);
    dp2[i] = Math.max(dp2[i - 1], prices[i] + dp1[i - 1]);
  }

  return dp2[dp2.length - 1];
};
```
#### [买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  if (prices.length === 0 || prices.length === 1) {
    return 0;
  }

  const dp1 = [];
  dp1[0] = -prices[0];

  const dp2 = [];
  dp2[0] = 0;

  for (let i = 1; i < prices.length; i++) {
    dp1[i] = Math.max(dp1[i - 1], dp2[i - 1] - prices[i]);
    dp2[i] = Math.max(dp2[i - 1], prices[i] + dp1[i - 1]);
  }

  return dp2[prices.length - 1];
};
```
#### [买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  if (prices.length === 0 || prices.length === 1) {
    return 0;
  }

  // 持有股票
  const dp1 = [
    [-prices[0]], // 还剩下两次交易机会
    [-prices[0]], // 还剩下一次交易机会
  ];
  // 不持有股票
  const dp2 = [
    [0], // 还剩下两次交易机会
    [0], // 还剩下一次交易机会
  ];

  for (let i = 1; i < prices.length; i++) {
    // 持有股票，还有两次交易机会
    dp1[0][i] = Math.max(dp1[0][i - 1], -prices[i]);
    // 持有股票，还有一次交易机会
    dp1[1][i] = Math.max(dp1[1][i - 1], dp2[0][i - 1] - prices[i]);
    // 不持有股票，还有两次交易机会
    dp2[0][i] = Math.max(dp2[0][i - 1], prices[i] + dp1[0][i - 1]);
    // 不持有股票，还有一次交易机会
    dp2[1][i] = Math.max(dp2[1][i - 1], prices[i] + dp1[1][i - 1]);
  }

  return dp2[1][prices.length - 1];
};
```
[参考原文](https://juejin.cn/post/6844903955030343694)
#### [最长公共子序列](https://leetcode.cn/problems/qJnOS7/)
```js
var longestCommonSubsequence = function (text1, text2) {
    const m = text1.length;
    const n = text2.length;
    const dp = [new Array(n + 1).fill(0)];
    for (let i = 1; i <= m; i++) {
        const c1 = text1[i - 1];
        dp[i] = [0];
        for (let j = 1; j <= n; j++) {
            const c2 = text2[j - 1];
            if (c1 === c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        } 
    }
    return dp[m][n];
};
```
#### [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)
```js
// 暴力解
var lengthOfLIS = function(nums) {
    let n = nums.length;
    if(n<=1){
        return n;
    }
    let max = 1;
    let dp = new Array(n).fill(1);
    for(let i=1; i<n; i++){
        for(let j=i-1; j>=0; j--){
            if(nums[i]>nums[j]){
                dp[i] = Math.max(dp[j]+1, dp[i]);
            }
        }
        max = Math.max(dp[i], max);
    }
    return max;
};
// 二分优化
var lengthOfLIS = function (nums) {
    let n = nums.length;
    if (n <= 1) {
        return n;
    }
    let len = 1;
    let dp = [null, nums[0]];
    for (let i = 1; i < n; i++) {
        if (dp[len] < nums[i]) {
            dp[++len] = nums[i];
            continue;
        }
        // 否则去dp中二分查找，判读插入位置
        let left = 1, right = len, mid, pos = 0; 
        while (left <= right) {
            mid = (left + right) >> 1;
            if (nums[i] > dp[mid]) {
                // 元素在右边
                left = mid + 1;
                pos = mid;
            } else {
                right = mid - 1;
            }
        }
        dp[pos + 1] = nums[i];
    }
    return len;
};
```
![最长递增子序列](https://github.com/lujiajian1/study-notes/blob/main/img/lengthOfLIS1.jpg)
![最长递增子序列](https://github.com/lujiajian1/study-notes/blob/main/img/lengthOfLIS2.jpg)
#### [鸡蛋掉落-两枚鸡蛋](https://leetcode.cn/problems/egg-drop-with-2-eggs-and-n-floors/)
```js
/**
 * https://mp.weixin.qq.com/s/qYOi0DeHo_OLmI7GHAAa2w
*/
var twoEggDrop = function(n) {
    // dp[i][j]代表有i+1个鸡蛋，共j层楼，得到f需要的最小操作次数
    // const dp = [0, 1, 2, ]
    const dp = [[],[]]
    dp[0][0] = dp[1][0] = 0；
    for(let j=0; j<=n; j++) {
        dp[0][j] = j;
    }
    for(let j=1; j<=n; j++) {
        for(let k=1; k<=j; k++) {
            if(isNaN(dp[1][j])) {
                dp[1][j] = Math.max(dp[0][k - 1] + 1, dp[1][j-k] + 1);
            } else {
                dp[1][j] = Math.min(dp[1][j], Math.max(dp[0][k - 1] + 1, d p[1][j-k] + 1));
            }
        }
    }
    return dp[1][n]
};
```
#### [鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)
```js
/**
 * @param {number} k 个鸡蛋，n层楼
 * @param {number} n 层楼
 * @return {number}
*/
var superEggDrop = function(k, n) {
    const memo = new Map()
    return dp(k, n)
    function dp(k, n){
        if(!(memo.has(n*100+k))) {
            // 计算
            let ans = null
            if(k===0||n===0) {
                ans = 0
            } else if(k===1) {
                ans = n
            } else if(n===1) {
                ans = 1
            } else {
                // 二分查找最优的x
                let low = 1, high = n, ans1, ans2
                while(low+1<high){
                    let x = (low + high) >> 1
                    ans1 = dp(k-1, x-1)
                    ans2 = dp(k, n-x)
                    if(ans1<ans2) {
                        low = x
                    } else if(ans1>ans2) {
                        high = x
                    } else {
                        low = high = x
                    }
                }
                ans1 = Math.max(dp(k-1, low-1), dp(k ,n-low))
                ans2 = Math.max(dp(k-1, high-1), dp(k ,n-high))
                ans = 1 + Math.min(ans1, ans2)
            }
            memo.set(n*100+k, ans)
        }
        return memo.get(n*100+k)
    }
}
```
#### [编辑距离](https://leetcode-cn.com/problems/edit-distance/)
```js
var minDistance = function (word1, word2) {
  let row = word1.length;
  let col = word2.length;
  //创建dp矩阵
  const dp = [];
  //为了创建二维矩阵，所用到的辅助的矩阵
  let tmp = new Array(col + 1).fill(0);
  for (let i = 0; i < row + 1; i++) {
    dp[i] = [...tmp];
  }
  // dp矩阵的第一行
  for (let j = 1; j <= col; j++) dp[0][j] = dp[0][j - 1] + 1;
  // dp矩阵的第一列
  for (let i = 1; i <= row; i++) dp[i][0] = dp[i - 1][0] + 1;
  // dp矩阵的其它元素
  for (let i = 1; i <= row; i++) {
    for (let j = 1; j <= col; j++) {
      //当前字母相等时
      if (word1[i - 1] === word2[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1];
        //如果当前字母不等
      } else {
        dp[i][j] =
          Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
      }
    }
  }
  return dp[row][col];
};
```
[参考原文](https://juejin.cn/post/6844903823270477837)
#### [不相交的线](https://leetcode.cn/problems/uncrossed-lines/description/)
```js
var maxUncrossedLines = function(nums1, nums2) {
    const m = nums1.length, n = nums2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 1; i <= m; i++) {
        const num1 = nums1[i - 1];
        for (let j = 1; j <= n; j++) {
            const num2 = nums2[j - 1];
            if (num1 === num2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```
[参考原文](https://leetcode.cn/problems/uncrossed-lines/solutions/787955/bu-xiang-jiao-de-xian-by-leetcode-soluti-6tqz/)
## 哈希表
哈希表：也叫做散列表。是根据关键字和值（Key-Value）直接进行访问的数据结构。也就是说，它通过关键字 key 和一个映射函数 Hash(key) 计算出对应的值 value，然后把键值对映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数（散列函数），用于存放记录的数组叫做 哈希表（散列表）。 哈希表的关键思想是使用哈希函数，将键 key 和值 value 映射到对应表的某个区块中。可以将算法思想分为两个部分：
* 向哈希表中插入一个关键字：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中
* 在哈希表中搜索一个关键字：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值
![哈希表](https://github.com/lujiajian1/study-notes/blob/main/img/hash.jpg)
#### [LRU 缓存](https://leetcode.cn/problems/lru-cache/)
```js
/**
 * @param {number} capacity
*/
var LRUCache = function(capacity) {
    this.map = new Map();
    this.capacity = capacity;
};
/**
 * @param {number} key
 * @return {number}
*/
LRUCache.prototype.get = function(key) {
    let value = this.map.get(key)
    if(value!==undefined) {
        this.map.delete(key)
        this.map.set(key, value)
        return value
    }
    return -1
};
/**
 * @param {number} key
 * @param {number} value
 * @return {void}
*/
LRUCache.prototype.put = function(key, value) {
    if(this.map.has(key)) {
        this.map.delete(key)
    }
    // 检查是否超载
    if(this.capacity===this.map.size) {
        const {value: key} = this.map.keys().next()
        this.map.delete(key)
    }
    this.map.set(key, value)
};
```
#### [按公因数计算最大组件大小](https://leetcode.cn/problems/largest-component-size-by-common-factor/description/)
```js
var largestComponentSize = function(nums) {
    const m = Math.max(...nums);
    const uf = new UnionFind(m + 1);
    for (const num of nums) {
        for (let i = 2; i * i <= num; i++) {
            if (num % i === 0) {
                uf.union(num, i);
                uf.union(num, Math.floor(num / i));
            }
        }
    }
    const counts = new Array(m + 1).fill(0);
    let ans = 0;
    for (let num of nums) {
        const root = uf.find(num);
        counts[root]++;
        ans = Math.max(ans, counts[root]);
    }
    return ans;
};

class UnionFind {
    constructor(n) {
        this.parent = new Array(n).fill(0).map((_, i) => i);
        this.rank = new Array(n).fill(0);
    }

    union(x, y) {
        let rootx = this.find(x);
        let rooty = this.find(y);
        if (rootx !== rooty) {
            if (this.rank[rootx] > this.rank[rooty]) {
                this.parent[rooty] = rootx;
            } else if (this.rank[rootx] < this.rank[rooty]) {
                this.parent[rootx] = rooty;
            } else {
                this.parent[rooty] = rootx;
                this.rank[rootx]++;
            }
        }
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);
        }
        return this.parent[x];
    }
}
```
[参考原文](https://leetcode.cn/problems/largest-component-size-by-common-factor/solutions/1706239/an-gong-yin-shu-ji-suan-zui-da-zu-jian-d-amdx/)
#### [按位与为零的三元组](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/description/)
```js
var countTriplets = function(nums) {
    const cnt = new Array(1 << 16).fill(0);
    for (const x of nums) {
        for (const y of nums) {
            ++cnt[x & y];
        }
    }
    let ans = 0;
    for (const x of nums) {
        for (let mask = 0; mask < (1 << 16); ++mask) {
            if ((x & mask) === 0) {
                ans += cnt[mask];
            }
        }
    }
    return ans;
};
```
[参考原文](https://leetcode.cn/problems/triples-with-bitwise-and-equal-to-zero/solutions/2144239/an-wei-yu-wei-ling-de-san-yuan-zu-by-lee-gjud/)
